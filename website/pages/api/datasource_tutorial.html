
<script type="text/javascript" id="documentation_options" data-url_root="./"
  src="/js/documentation_options.js"></script>
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/underscore.js"></script>
<script type="text/javascript" src="/js/doctools.js"></script>
<script type="text/javascript" src="/js/language_data.js"></script>
<script type="text/javascript" src="/js/searchtools.js"></script>
<div class="sphinx"><div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body" role="main">
<div class="section" id="custom-data-format">
<h1>Custom Data Format<a class="headerlink" href="#custom-data-format" title="Permalink to this headline">¶</a></h1>
<p>PyText’s default reader is <code class="xref py py-class docutils literal notranslate"><span class="pre">TSVDataSource</span></code> to read your dataset if it’s in tsv format (tab-separated values). In many cases, your data is going to be in a different format. You could write a pre-processing script to format your data into tsv format, but it’s easier and more convenient to implement your own <code class="xref py py-class docutils literal notranslate"><span class="pre">DataSource</span></code> component so that PyText can read your data directly, without any preprocessing.</p>
<p>This tutorial explains how to implement a simple <code class="xref py py-class docutils literal notranslate"><span class="pre">DataSource</span></code> that can read the ATIS data and to perform a classification task using the “intent” labels.</p>
<div class="section" id="download-the-data">
<h2>1. Download the data<a class="headerlink" href="#download-the-data" title="Permalink to this headline">¶</a></h2>
<p>Download the <a class="reference external" href="https://www.kaggle.com/siddhadev/ms-cntk-atis/downloads/atis.zip/3">ATIS (Airline Travel Information System) dataset</a> and unzip it in a directory. Note that to download the dataset, you will need a <a class="reference external" href="https://www.kaggle.com/">Kaggle</a> account for which you can sign up for free. The zip file is about 240KB.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> unzip &lt;download_dir&gt;/atis.zip -d &lt;download_dir&gt;/atis
</pre></div>
</div>
</div>
<div class="section" id="the-data-format">
<h2>2. The data format<a class="headerlink" href="#the-data-format" title="Permalink to this headline">¶</a></h2>
<p>The ATIS dataset has a few defining characterics:</p>
<ol class="arabic simple">
<li><p>it has a train set and a test set, but not eval set</p></li>
<li><p>the data is split into a “dict” file, which is a vocab file containing the words or labels, and the train and test sets, which only contain integers representing the word indexes.</p></li>
<li><p>sentences always start with the token 178 = BOS (Beginning Of Sentence) and end with the token 179 = EOS (End Of Sentence).</p></li>
</ol>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> tail atis/atis.dict.vocab.csv
<span class="go">y</span>
<span class="go">year</span>
<span class="go">yes</span>
<span class="go">yn</span>
<span class="go">york</span>
<span class="go">you</span>
<span class="go">your</span>
<span class="go">yx</span>
<span class="go">yyz</span>
<span class="go">zone</span>
<span class="gp">$</span> tail atis/atis.test.query.csv
<span class="go">178 479 0 545 851 264 882 429 851 915 330 179</span>
<span class="go">178 479 902 851 264 180 428 444 736 521 301 851 915 330 179</span>
<span class="go">178 818 581 207 827 204 616 915 330 179</span>
<span class="go">178 479 0 545 851 264 180 428 444 299 851 619 937 301 654 887 200 435 621 740 179</span>
<span class="go">178 818 581 207 827 204 482 827 619 937 301 229 179</span>
<span class="go">178 688 423 207 827 429 444 299 851 218 203 482 827 619 937 301 229 826 236 621 740 253 130 689 179</span>
<span class="go">178 423 581 180 428 444 299 851 218 203 482 827 619 937 301 229 179</span>
<span class="go">178 479 0 545 851 431 444 589 851 297 654 212 200 179</span>
<span class="go">178 479 932 545 851 264 180 730 870 428 444 511 301 851 297 179</span>
<span class="go">178 423 581 180 428 826 427 444 587 851 810 179</span>
</pre></div>
</div>
<p>Our <code class="xref py py-class docutils literal notranslate"><span class="pre">DataSource</span></code> must then resolve the words from the vocab files to rebuild the sentences and labels as strings. It must also take a subset the one of train or test dataset to create the eval dataset. Since the test set is pretty small, we’ll use the train set for that purpose and randomly take a small fraction (say 25%) to create the eval set. Finally, we can safely remove the first and last tokens of every query (BOS and EOS), as they don’t add any value for classification.</p>
<p>The ATIS dataset also has information for slots tagging that we’ll ignore because we only care about classification in this tutorial.</p>
</div>
<div class="section" id="datasource">
<h2>3. DataSource<a class="headerlink" href="#datasource" title="Permalink to this headline">¶</a></h2>
<p>PyText defines a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataSource</span></code> to read the data. It expect each row of data to be represented as a python dict where the keys are the column names and the values are the columns properly typed.</p>
<p>Most of the time, the dataset will come as strings and the casting to the proper types can be inferred automatically from the other components in the config. To make the implementation of a new <code class="xref py py-class docutils literal notranslate"><span class="pre">DataSource</span></code> easier, PyText provides the class <code class="xref py py-class docutils literal notranslate"><span class="pre">RootDataSource</span></code> that does this type lookup for you. Most users should use <code class="xref py py-class docutils literal notranslate"><span class="pre">RootDataSource</span></code> as a base class.</p>
</div>
<div class="section" id="implementing-atisintentdatasource">
<h2>4. Implementing <cite>AtisIntentDataSource</cite><a class="headerlink" href="#implementing-atisintentdatasource" title="Permalink to this headline">¶</a></h2>
<p>We will write the all the code for our <code class="xref py py-class docutils literal notranslate"><span class="pre">AtisIntentDataSource</span></code> in the file <cite>my_classifier/source.py</cite>.</p>
<p>First, let’s write the utilities that will help us read the data: a function to load the vocab files, and the generator that uses them to rebuild the sentences and labels. We return pytext.data.utils.UNK for unknown words. We store the indexes as strings to avoid casting from and to ints when reading the inputs.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_vocab</span><span class="p">(</span><span class="n">file_path</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Given a file, prepare the vocab dictionary where each line is the value and</span>
<span class="sd">    (line_no - 1) is the key</span>
<span class="sd">    """</span>
    <span class="n">vocab</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_contents</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">file_contents</span><span class="p">):</span>
            <span class="n">vocab</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">vocab</span>

<span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">vocab</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s2">" "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">vocab</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">UNK</span><span class="p">)</span>
                <span class="c1"># ATIS every row starts/ends with BOS/EOS: remove them</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>Then we declate the <code class="xref py py-class docutils literal notranslate"><span class="pre">DataSource</span></code> class itself: <code class="xref py py-class docutils literal notranslate"><span class="pre">AtisIntentDataSource</span></code>. It inherits from <code class="xref py py-class docutils literal notranslate"><span class="pre">RootDataSource</span></code>, which gives us the automatic lookup of data types. We declare all the config parameters that will be useful, and give sensible default values so that the general case where users provide only <cite>path</cite> and <cite>field_names</cite> will likely work. We load the vocab files for queries and intent only once in the constructor and keep them in memory for the entire run:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">AtisIntentDataSource</span><span class="p">(</span><span class="n">RootDataSource</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="s2">"my_directory"</span><span class="p">,</span>
        <span class="n">field_names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">validation_split</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="mi">12345</span><span class="p">,</span>
        <span class="c1"># Filenames can be overridden if necessary</span>
        <span class="n">intent_filename</span><span class="o">=</span><span class="s2">"atis.dict.intent.csv"</span><span class="p">,</span>
        <span class="n">vocab_filename</span><span class="o">=</span><span class="s2">"atis.dict.vocab.csv"</span><span class="p">,</span>
        <span class="n">test_queries_filename</span><span class="o">=</span><span class="s2">"atis.test.query.csv"</span><span class="p">,</span>
        <span class="n">test_intent_filename</span><span class="o">=</span><span class="s2">"atis.test.intent.csv"</span><span class="p">,</span>
        <span class="n">train_queries_filename</span><span class="o">=</span><span class="s2">"atis.train.query.csv"</span><span class="p">,</span>
        <span class="n">train_intent_filename</span><span class="o">=</span><span class="s2">"atis.train.intent.csv"</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">field_names</span> <span class="o">=</span> <span class="n">field_names</span> <span class="ow">or</span> <span class="p">[</span><span class="s2">"text"</span><span class="p">,</span> <span class="s2">"label"</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_names</span> <span class="ow">or</span> <span class="p">[])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> \
           <span class="s2">"AtisIntentDataSource only handles 2 field_names: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_names</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">random_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_split</span> <span class="o">=</span> <span class="n">eval_split</span>

        <span class="c1"># Load the vocab dict in memory for the readers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">=</span> <span class="n">load_vocab</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">vocab_filename</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intents</span> <span class="o">=</span> <span class="n">load_vocab</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">intent_filename</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">query_field</span> <span class="o">=</span> <span class="n">field_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intent_field</span> <span class="o">=</span> <span class="n">field_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">test_queries_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">test_queries_filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_intent_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">test_intent_filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_queries_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">train_queries_filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_intent_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">train_intent_filename</span><span class="p">)</span>
</pre></div>
</div>
<p>To generate the eval data set, we need to randomly select some of the rows in training, but in a consistent and repeatable way. This is not strictly needed, and the training will work if the selection were completely random, but having a consistent sequence will help with debugging and give comparable results from training to training. In order to do that, we need to use the same seed for a new random number generator each time we start reading the train data set. The function below can be used for either training or eval and ensures that those two sets are complement of each other, with the ratio determined by eval_split. This function returns True or False depending on whether the row should be included or not:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select_eval</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    This selector ensures that the same pseudo-random sequence is</span>
<span class="sd">    always the used from the Beginning. The `select_eval` parameter</span>
<span class="sd">    guarantees that the training set and eval set are exact complements.</span>
<span class="sd">    """</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">Random</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fn</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">select_eval</span> <span class="o">^</span> <span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_split</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fn</span>
</pre></div>
</div>
<p>Next, we write the function that iterates through both the <cite>reader</cite> for the queries (sentences) and the <cite>reader</cite> for the intents (labels) simultaneously. It yields each row in the form a python dictionnary, where the keys are the <cite>field_names</cite>. We can pass an optional function to select a subset of the row (ie: _selector defined above); the default is to select all the rows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_iter_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query_reader</span><span class="p">,</span> <span class="n">intent_reader</span><span class="p">,</span> <span class="n">select_fn</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">True</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">query_str</span><span class="p">,</span> <span class="n">intent_str</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">query_reader</span><span class="p">,</span> <span class="n">intent_reader</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">select_fn</span><span class="p">():</span>
            <span class="k">yield</span> <span class="p">{</span>
                <span class="c1"># in ATIS every row starts/ends with BOS/EOS: remove them</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">query_field</span><span class="p">:</span> <span class="n">query_str</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intent_field</span><span class="p">:</span> <span class="n">intent_str</span><span class="p">,</span>
            <span class="p">}</span>
</pre></div>
</div>
<p>Finally, we tie everything toghether by implementing the 3 API methods of <code class="xref py py-class docutils literal notranslate"><span class="pre">RootDataSource</span></code>. Each of those methods should return a generator that can iterate through the specific dataset entirely. For the test dataset, we simply return all the row presented by the data in test_queries_filepath and test_intent_filepath, using the corresponding vocab:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">raw_test_data_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_rows</span><span class="p">(</span>
        <span class="n">query_reader</span><span class="o">=</span><span class="n">reader</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">test_queries_filepath</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">intent_reader</span><span class="o">=</span><span class="n">reader</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">test_intent_filepath</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intents</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">))</span>
</pre></div>
</div>
<p>For the eval and train datasets, we read the same files train_queries_filepath and train_intent_filepath, but we select some of the rows for eval and the rest for train:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">raw_train_data_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_rows</span><span class="p">(</span>
        <span class="n">query_reader</span><span class="o">=</span><span class="n">reader</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_queries_filepath</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">intent_reader</span><span class="o">=</span><span class="n">reader</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_intent_filepath</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intents</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">select_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="p">(</span><span class="n">select_eval</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span>
    <span class="p">))</span>

<span class="k">def</span> <span class="nf">raw_eval_data_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_rows</span><span class="p">(</span>
        <span class="n">query_reader</span><span class="o">=</span><span class="n">reader</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_queries_filepath</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">words</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">intent_reader</span><span class="o">=</span><span class="n">reader</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_intent_filepath</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intents</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">select_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_selector</span><span class="p">(</span><span class="n">select_eval</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span>
    <span class="p">))</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">RootDataSource</span></code> needs to know how it should transform the values in the dictionnaries created by the raw generators into the types matching the tensorizers used in the model. Fortunately, <code class="xref py py-class docutils literal notranslate"><span class="pre">RootDataSource</span></code> already provides a number of type conversion functions like the one below, so we don’t need to do it for strings. If we did need to do it, we would declare one like this for <code class="xref py py-class docutils literal notranslate"><span class="pre">AtisIntentDataSource</span></code>.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@AtisIntentDataSource.register_type</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">load_string</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>The full source code for this tutorial can be found in <cite>demo/datasource/source.py</cite>, which include the <cite>imports</cite> needed.</p>
</div>
<div class="section" id="testing-atisintentdatasource">
<h2>5. Testing <cite>AtisIntentDataSource</cite><a class="headerlink" href="#testing-atisintentdatasource" title="Permalink to this headline">¶</a></h2>
<p>For rapid dev-test cycles, we add a simple main code printing the generated data in the terminal:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">AtisIntentDataSource</span><span class="p">(</span>
        <span class="n">path</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">field_names</span><span class="o">=</span><span class="p">[</span><span class="s2">"query"</span><span class="p">,</span> <span class="s2">"intent"</span><span class="p">],</span>
        <span class="n">schema</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">raw_train_data_generator</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"TRAIN"</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">raw_eval_data_generator</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"EVAL"</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">raw_test_data_generator</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">"TEST"</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>We test our class to make sure we’re getting the right data.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> python3 my_classifier/source.py atis <span class="p">|</span> head -n <span class="m">3</span>
<span class="go">TRAIN {'query': 'what flights are available from pittsburgh to baltimore on thursday morning', 'intent': 'flight'}</span>
<span class="go">TRAIN {'query': 'cheapest airfare from tacoma to orlando', 'intent': 'airfare'}</span>
<span class="go">TRAIN {'query': 'round trip fares from pittsburgh to philadelphia under 1000 dollars', 'intent': 'airfare'}</span>

<span class="gp">$</span> python3 my_classifier/source.py atis <span class="p">|</span> cut -d <span class="s2">" "</span> -f <span class="m">1</span> <span class="p">|</span> uniq -c
<span class="go">3732 TRAIN</span>
<span class="go">1261 EVAL</span>
<span class="go"> 893 TEST</span>
</pre></div>
</div>
</div>
<div class="section" id="training-the-model">
<h2>6. Training the Model<a class="headerlink" href="#training-the-model" title="Permalink to this headline">¶</a></h2>
<p>First let’s get a config using our new <code class="xref py py-class docutils literal notranslate"><span class="pre">AtisIntentDataSource</span></code></p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> pytext --include my_classifier gen-default-config DocumentClassificationTask AtisIntentDataSource &gt; my_classifier/config.json
<span class="go">Including: my_classifier</span>
<span class="go">... importing module: my_classifier.source</span>
<span class="go">... importing: &lt;class 'my_classifier.source.AtisIntentDataSource'&gt;</span>
<span class="go">INFO - Applying option: task-&gt;data-&gt;source = AtisIntentDataSource</span>
</pre></div>
</div>
<p>This default config contains all the parameters with their default value. So we edit the config to remove the parameters that we don’t care about, and we edit the ones we care about. We only want to run 3 epochs for now. It looks like this.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> cat my_classifier/config.json
<span class="go">{</span>
<span class="go">  "debug_path": "my_classifier.debug",</span>
<span class="go">  "export_caffe2_path": "my_classifier.caffe2.predictor",</span>
<span class="go">  "export_onnx_path": "my_classifier.onnx",</span>
<span class="go">  "save_snapshot_path": "my_classifier.pt",</span>
<span class="go">  "task": {</span>
<span class="go">    "DocumentClassificationTask": {</span>
<span class="go">      "data": {</span>
<span class="go">        "Data": {</span>
<span class="go">          "source": {</span>
<span class="go">            "AtisIntentDataSource": {</span>
<span class="go">              "field_names": ["text", "label"],</span>
<span class="go">              "path": "atis",</span>
<span class="go">              "random_seed": 12345,</span>
<span class="go">              "validation_split": 0.25</span>
<span class="go">            }</span>
<span class="go">          }</span>
<span class="go">        }</span>
<span class="go">      },</span>
<span class="go">      "metric_reporter": {</span>
<span class="go">        "output_path": "my_classifier.out"</span>
<span class="go">      },</span>
<span class="go">      "trainer": {</span>
<span class="go">        "epochs": 3</span>
<span class="go">      }</span>
<span class="go">    }</span>
<span class="go">  },</span>
<span class="go">  "test_out_path": "my_classifier_test.out",</span>
<span class="go">  "version": 12</span>
<span class="go">}</span>
</pre></div>
</div>
<p>And, at last, we can train the model</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> pytext --include my_classifier train &lt; my_classifier/config.json
</pre></div>
</div>
</div>
<div class="section" id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<p>In the current version of PyText, we need to explicitly declare a few more things, like the <cite>Config</cite> class (that looks like the __init__ parameters) and the from_config method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Config</span><span class="p">(</span><span class="n">RootDataSource</span><span class="o">.</span><span class="n">Config</span><span class="p">):</span>
    <span class="n">path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"."</span>
    <span class="n">field_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"text"</span><span class="p">,</span> <span class="s2">"label"</span><span class="p">]</span>
    <span class="n">validation_split</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">12345</span>
    <span class="c1"># Filenames can be overridden if necessary</span>
    <span class="n">intent_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"atis.dict.intent.csv"</span>
    <span class="n">vocab_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"atis.dict.vocab.csv"</span>
    <span class="n">test_queries_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"atis.test.query.csv"</span>
    <span class="n">test_intent_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"atis.test.intent.csv"</span>
    <span class="n">train_queries_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"atis.train.query.csv"</span>
    <span class="n">train_intent_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">"atis.train.intent.csv"</span>

<span class="c1"># Config mimics the constructor</span>
<span class="c1"># This will be the default in future pytext.</span>
<span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">from_config</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">Config</span><span class="p">,</span> <span class="n">schema</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Type</span><span class="p">]):</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="o">**</span><span class="n">config</span><span class="o">.</span><span class="n">_asdict</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">PyText</a></h1>
<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="train_your_first_model.html">Train your first model</a></li>
<li class="toctree-l1"><a class="reference internal" href="execute_your_first_model.html">Execute your first model</a></li>
<li class="toctree-l1"><a class="reference internal" href="visualize_your_model.html">Visualize Model Training with TensorBoard</a></li>
<li class="toctree-l1"><a class="reference internal" href="pytext_models_in_your_app.html">Use PyText models in your app</a></li>
<li class="toctree-l1"><a class="reference internal" href="serving_models_in_production.html">Serve Models in Production</a></li>
<li class="toctree-l1"><a class="reference internal" href="config_files.html">Config Files Explained</a></li>
<li class="toctree-l1"><a class="reference internal" href="config_commands.html">Config Commands</a></li>
</ul>
<p class="caption"><span class="caption-text">Training More Advanced Models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="atis_tutorial.html">Train Intent-Slot model on ATIS Dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="hierarchical_intent_slot_tutorial.html">Hierarchical intent and slot filling</a></li>
<li class="toctree-l1"><a class="reference internal" href="disjoint_multitask_tutorial.html">Multitask training with disjoint datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributed_training_tutorial.html">Data Parallel Distributed Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="xlm_r.html">XLM-RoBERTa</a></li>
</ul>
<p class="caption"><span class="caption-text">Extending PyText</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Architecture Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Custom Data Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="tensorizer.html">Custom Tensorizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="dense.html">Using External Dense Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="create_new_model.html">Creating A New Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="hacking_pytext.html">Hacking PyText</a></li>
</ul>
<p class="caption"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="configs/pytext.html">pytext</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules/pytext.html">pytext package</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="index.html">Documentation overview</a><ul>
<li>Previous: <a href="overview.html" title="previous chapter">Architecture Overview</a></li>
<li>Next: <a href="tensorizer.html" title="next chapter">Custom Tensorizer</a></li>
</ul></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3 id="searchlabel">Quick search</h3>
<div class="searchformwrapper">
<form action="search.html" class="search" method="get">
<input aria-labelledby="searchlabel" name="q" type="text"/>
<input type="submit" value="Go"/>
</form>
</div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div></div>